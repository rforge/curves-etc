
R version 2.12.0 alpha (2010-09-24 r52998)
Copyright (C) 2010 The R Foundation for Statistical Computing
ISBN 3-900051-07-0
Platform: x86_64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> require(lokern)
Loading required package: lokern
Loading required package: sfsmisc
> data(xSim)
> n <- length(xSim)
> stopifnot(n == 75)
> tt <- ((1:n) - 1/2)/n # equidistant x
> 
> (gk <- glkerns(tt, xSim))
Call:
glkerns(x = tt, y = xSim)
List of 23
 $ x         : num [1:75] 0.006666667 0.02 0.033333333 0.046666667 0.06 ...
 $ y         : num [1:75] 1.9666 1.9 1.6449 1.4275 2.4 1.8487 1.3383 1.9514 1.5722 1.1978 ...
 $ x.out     : num [1:300] 0.006666667 0.011032448 0.01539823 0.019764012 0.02 ...
 $ est       : num [1:300] 1.867502 1.860786 1.85407 1.847354 1.846991 ...
 $ n         : int 75
 $ n.out     : int 300
 $ deriv     : int 0
 $ korder    : int 2
 $ hetero    : logi FALSE
 $ is.rand   : logi TRUE
 $ inputb    : logi FALSE
 $ iter      : int 15
 $ xl        : num 0.067
 $ xu        : num 0.933
 $ s         : num [1:76] 0.004117607 0.013333333 0.026666667 0.04 0.053333333 ...
 $ sig       : num 0.1451065
 $ bandwidth : num 0.04845241
 $ ind.x     : int [1:75] 1 5 9 13 17 21 25 29 33 37 ...
 $ seqXmethod: chr "aim"
 $ m1        : int 400
 $ isOrd     : logi TRUE
 $ ord       : NULL
 $ x.inOut   : logi TRUE
> summary(gk$est)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
-3.0680 -1.6680  0.7053  0.4094  1.7820  4.2130 
> gk$bandwidth
[1] 0.04845241
> glkerns(tt,xSim, deriv = 1)$bandwidth
[1] 0.08137163
> glkerns(tt,xSim, deriv = 2)$bandwidth
[1] 0.1190404
> 
> demo("glk-derivs")


	demo(glk-derivs)
	---- ~~~~~~~~~~

> ## Q: Can we have *same* kernel, *same* bandwidth  with different  'deriv'
> ##    similarly to smooth.spline() ?
> ##
> ## Answer: not really,  mainly because don't have enough choices
> ##     (nu, k_{ord}), i.e., because currently,  nu - k  must be even ...
> 
> ## "dput(.) of simple integer vector to character :
> myF <- function(d, A="(", O=")", B = length(d) > 1)
+     paste(if(B) A, paste(d, collapse=", "), if(B) O, sep="")

> library(lokern)

> p.3glks <- function(x.dat, y.dat, korder, derivs = 0:2,
+                     is.rand=FALSE, useBandwidth, bw.factor = 1.8,
+                     col = 2, lwd = 1.5)
+ {
+     ## Purpose: Plot  glkerns(*,  deriv = {0, 1, 2})
+     ## ----------------------------------------------------------------------
+     ## Arguments: (x.dat, y.dat): the numeric data vectors
+     ##            korder : the kernel order -- automatically is diminuished by one
+     ##                     if needed to keep  'korder - deriv' an even number
+     ##            derivs : integer vectors of derivatives to compute
+     ##            useBandwidth: possibly a user specified bandwidth
+     ## ----------------------------------------------------------------------
+     ## Author: Martin Maechler, Date:  2 Jul 2009, 09:24
+ 
+     if(!missing(useBandwidth) && is.numeric(useBandwidth) && useBandwidth > 0)
+         bw <- useBandwidth
+     else {
+         ## Determine the fixed bandwidth :
+         bw0 <- glkerns(x.dat, y.dat, korder=korder, is.rand=is.rand)$bandwidth
+         bw <- bw0 * bw.factor     # more smoothing for the derivatives
+     }
+ 
+     stopifnot(derivs == (d <- as.integer(derivs)), length(derivs) >= 1)
+     derivs <- d
+     stopifnot(0 <= derivs, derivs <= 4)
+     glist <- as.list(derivs)
+     ## Estimates for   g, g' , g'' ... {well, depending on derivs} :
+     for(i.d in seq_along(derivs)) {
+         nu <- derivs[i.d]
+         k0 <- korder
+         if((korder - nu) %% 2 != 0) { ## 'korder - nu' must be even {theory; Fortran code}
+             k0 <- korder - 1
+             message(gettextf("deriv = %d: modifying korder from %d to %d",
+                              nu, korder, k0))
+         }
+         glist[[i.d]] <-
+             glkerns(x.dat, y.dat, korder=k0, is.rand=is.rand, bandw = bw, deriv = nu)
+     }
+ 
+     names(glist) <- paste("nu=", derivs, sep="")
+ 
+     ## ---------  Plots ---------------
+ 
+     op <- par(mfrow= c(length(derivs), 1), mgp = c(1.25, 0.6, 0),
+               mar = c(3,3,2.5,1) + .1, oma = c(0,0, 2, 0))
+     on.exit(par(op))
+ 
+     for(i.d in seq_along(derivs)) {
+         nu <- derivs[i.d]
+         tit <-
+             switch(nu + 1,
+                    expression(widehat(g)(.)), # 0
+                    expression(widehat(g * minute)(.)), # 1: g'
+                    expression(widehat(g * second)(.)), # 2: g''
+                    expression(widehat(g * minute*second)(.)),# 3: g'''
+                    expression(widehat(g ^ {(4)})),
+                    expression(widehat(g ^ {(5)})),
+                    expression(widehat(g ^ {(6)})))
+ 
+         with(glist[[i.d]], {
+             plot(est ~ x.out, type = "l", main = tit, col=col, lwd=lwd)
+             if(nu == 0) ## data
+                 points(y ~ x, cex = 0.5)
+             else ## y = 0 line (to see zeros):
+                 abline(h = 0, col = "gray", lty=3)
+ 
+             mtext(substitute(list(bw == B,k[ord] == K),
+                              list(B = formatC(bandwidth), K = korder)),
+                   adj = 1, line = .25) })
+     }
+     mtext(sprintf("glkerns(*, deriv = %s, bandwidth = <fixed>, korder = %d)",
+                   myF(derivs, "{","}"), korder),
+           line = 0.5, outer = TRUE, cex = par("cex.main"), font = par("font.main"))
+ 
+     invisible(glist)
+ }

> data(xSim)

> n <- length(xSim)

> tt <- ((1:n) - 1/2)/n # equidistant x

> p.3glks(tt, xSim, kord = 4)
deriv = 1: modifying korder from 4 to 3

> ## Chose bandwidth yourself; see all available derivatives:
> ## Store results
> r <- p.3glks(tt, xSim, kord = 6,
+              derivs = 0:4, useBand = 0.15)
deriv = 1: modifying korder from 6 to 5
deriv = 3: modifying korder from 6 to 5

> ## and inspect them
> str(r)
List of 5
 $ nu=0:List of 24
  ..$ x         : num [1:75] 0.00667 0.02 0.03333 0.04667 0.06 ...
  ..$ y         : num [1:75] 1.97 1.9 1.64 1.43 2.4 ...
  ..$ x.out     : num [1:300] 0.00667 0.01103 0.0154 0.01976 0.02 ...
  ..$ est       : num [1:300] 1.92 1.89 1.87 1.85 1.85 ...
  ..$ n         : int 75
  ..$ n.out     : int 300
  ..$ deriv     : int 0
  ..$ korder    : int 6
  ..$ hetero    : logi FALSE
  ..$ is.rand   : logi FALSE
  ..$ inputb    : logi TRUE
  ..$ iter      : int NA
  ..$ xl        : num 1
  ..$ xu        : num 0
  ..$ s         : num [1:76] 0 0.0133 0.0267 0.04 0.0533 ...
  ..$ sig       : num 0
  ..$ bandwidth : num 0.15
  ..$ ind.x     : int [1:75] 1 5 9 13 17 21 25 29 33 37 ...
  ..$ seqXmethod: chr "aim"
  ..$ m1        : int 400
  ..$ isOrd     : logi TRUE
  ..$ ord       : NULL
  ..$ x.inOut   : logi TRUE
  ..$ call      : language glkerns(x = x.dat, y = y.dat, deriv = nu, korder = k0, is.rand = is.rand,      bandwidth = bw)
  ..- attr(*, "class")= chr [1:2] "glkerns" "KernS"
 $ nu=1:List of 24
  ..$ x         : num [1:75] 0.00667 0.02 0.03333 0.04667 0.06 ...
  ..$ y         : num [1:75] 1.97 1.9 1.64 1.43 2.4 ...
  ..$ x.out     : num [1:300] 0.00667 0.01103 0.0154 0.01976 0.02 ...
  ..$ est       : num [1:300] -2.75 -2.58 -2.44 -2.34 -2.33 ...
  ..$ n         : int 75
  ..$ n.out     : int 300
  ..$ deriv     : int 1
  ..$ korder    : int 5
  ..$ hetero    : logi FALSE
  ..$ is.rand   : logi FALSE
  ..$ inputb    : logi TRUE
  ..$ iter      : int NA
  ..$ xl        : num 1
  ..$ xu        : num 0
  ..$ s         : num [1:76] 0 0.0133 0.0267 0.04 0.0533 ...
  ..$ sig       : num 0
  ..$ bandwidth : num 0.15
  ..$ ind.x     : int [1:75] 1 5 9 13 17 21 25 29 33 37 ...
  ..$ seqXmethod: chr "aim"
  ..$ m1        : int 400
  ..$ isOrd     : logi TRUE
  ..$ ord       : NULL
  ..$ x.inOut   : logi TRUE
  ..$ call      : language glkerns(x = x.dat, y = y.dat, deriv = nu, korder = k0, is.rand = is.rand,      bandwidth = bw)
  ..- attr(*, "class")= chr [1:2] "glkerns" "KernS"
 $ nu=2:List of 24
  ..$ x         : num [1:75] 0.00667 0.02 0.03333 0.04667 0.06 ...
  ..$ y         : num [1:75] 1.97 1.9 1.64 1.43 2.4 ...
  ..$ x.out     : num [1:300] 0.00667 0.01103 0.0154 0.01976 0.02 ...
  ..$ est       : num [1:300] 355 305 258 214 212 ...
  ..$ n         : int 75
  ..$ n.out     : int 300
  ..$ deriv     : int 2
  ..$ korder    : int 6
  ..$ hetero    : logi FALSE
  ..$ is.rand   : logi FALSE
  ..$ inputb    : logi TRUE
  ..$ iter      : int NA
  ..$ xl        : num 1
  ..$ xu        : num 0
  ..$ s         : num [1:76] 0 0.0133 0.0267 0.04 0.0533 ...
  ..$ sig       : num 0
  ..$ bandwidth : num 0.15
  ..$ ind.x     : int [1:75] 1 5 9 13 17 21 25 29 33 37 ...
  ..$ seqXmethod: chr "aim"
  ..$ m1        : int 400
  ..$ isOrd     : logi TRUE
  ..$ ord       : NULL
  ..$ x.inOut   : logi TRUE
  ..$ call      : language glkerns(x = x.dat, y = y.dat, deriv = nu, korder = k0, is.rand = is.rand,      bandwidth = bw)
  ..- attr(*, "class")= chr [1:2] "glkerns" "KernS"
 $ nu=3:List of 24
  ..$ x         : num [1:75] 0.00667 0.02 0.03333 0.04667 0.06 ...
  ..$ y         : num [1:75] 1.97 1.9 1.64 1.43 2.4 ...
  ..$ x.out     : num [1:300] 0.00667 0.01103 0.0154 0.01976 0.02 ...
  ..$ est       : num [1:300] -1684 -1619 -1554 -1488 -1485 ...
  ..$ n         : int 75
  ..$ n.out     : int 300
  ..$ deriv     : int 3
  ..$ korder    : int 5
  ..$ hetero    : logi FALSE
  ..$ is.rand   : logi FALSE
  ..$ inputb    : logi TRUE
  ..$ iter      : int NA
  ..$ xl        : num 1
  ..$ xu        : num 0
  ..$ s         : num [1:76] 0 0.0133 0.0267 0.04 0.0533 ...
  ..$ sig       : num 0
  ..$ bandwidth : num 0.15
  ..$ ind.x     : int [1:75] 1 5 9 13 17 21 25 29 33 37 ...
  ..$ seqXmethod: chr "aim"
  ..$ m1        : int 400
  ..$ isOrd     : logi TRUE
  ..$ ord       : NULL
  ..$ x.inOut   : logi TRUE
  ..$ call      : language glkerns(x = x.dat, y = y.dat, deriv = nu, korder = k0, is.rand = is.rand,      bandwidth = bw)
  ..- attr(*, "class")= chr [1:2] "glkerns" "KernS"
 $ nu=4:List of 24
  ..$ x         : num [1:75] 0.00667 0.02 0.03333 0.04667 0.06 ...
  ..$ y         : num [1:75] 1.97 1.9 1.64 1.43 2.4 ...
  ..$ x.out     : num [1:300] 0.00667 0.01103 0.0154 0.01976 0.02 ...
  ..$ est       : num [1:300] 198209 192068 185921 179769 179436 ...
  ..$ n         : int 75
  ..$ n.out     : int 300
  ..$ deriv     : int 4
  ..$ korder    : int 6
  ..$ hetero    : logi FALSE
  ..$ is.rand   : logi FALSE
  ..$ inputb    : logi TRUE
  ..$ iter      : int NA
  ..$ xl        : num 1
  ..$ xu        : num 0
  ..$ s         : num [1:76] 0 0.0133 0.0267 0.04 0.0533 ...
  ..$ sig       : num 0
  ..$ bandwidth : num 0.15
  ..$ ind.x     : int [1:75] 1 5 9 13 17 21 25 29 33 37 ...
  ..$ seqXmethod: chr "aim"
  ..$ m1        : int 400
  ..$ isOrd     : logi TRUE
  ..$ ord       : NULL
  ..$ x.inOut   : logi TRUE
  ..$ call      : language glkerns(x = x.dat, y = y.dat, deriv = nu, korder = k0, is.rand = is.rand,      bandwidth = bw)
  ..- attr(*, "class")= chr [1:2] "glkerns" "KernS"
> 
> p.3glks(tt, xSim, kord = 3)
deriv = 0: modifying korder from 3 to 2
deriv = 2: modifying korder from 3 to 2
Warning messages:
1: In .glkerns(x = x, y = y, x.out = x.out, n = n, n.out = n.out, deriv = deriv,  :
  'korder' reset from 3 to 2, internally
2: In .glkerns(x = x, y = y, x.out = x.out, n = n, n.out = n.out, deriv = deriv,  :
  'korder' reset from 2 to 4, internally
> 
> p.3glks(tt, xSim, kord = 4, useB = 0.15)
deriv = 1: modifying korder from 4 to 3
> 
> str(p.3glks(tt, xSim, kord = 5, useB = 0.12) ) # k.ord = (4,5,4) => less sensiacl?
deriv = 0: modifying korder from 5 to 4
deriv = 2: modifying korder from 5 to 4
List of 3
 $ nu=0:List of 24
  ..$ x         : num [1:75] 0.00667 0.02 0.03333 0.04667 0.06 ...
  ..$ y         : num [1:75] 1.97 1.9 1.64 1.43 2.4 ...
  ..$ x.out     : num [1:300] 0.00667 0.01103 0.0154 0.01976 0.02 ...
  ..$ est       : num [1:300] 1.89 1.88 1.88 1.87 1.87 ...
  ..$ n         : int 75
  ..$ n.out     : int 300
  ..$ deriv     : int 0
  ..$ korder    : int 4
  ..$ hetero    : logi FALSE
  ..$ is.rand   : logi FALSE
  ..$ inputb    : logi TRUE
  ..$ iter      : int NA
  ..$ xl        : num 1
  ..$ xu        : num 0
  ..$ s         : num [1:76] 0 0.0133 0.0267 0.04 0.0533 ...
  ..$ sig       : num 0
  ..$ bandwidth : num 0.12
  ..$ ind.x     : int [1:75] 1 5 9 13 17 21 25 29 33 37 ...
  ..$ seqXmethod: chr "aim"
  ..$ m1        : int 400
  ..$ isOrd     : logi TRUE
  ..$ ord       : NULL
  ..$ x.inOut   : logi TRUE
  ..$ call      : language glkerns(x = x.dat, y = y.dat, deriv = nu, korder = k0, is.rand = is.rand,      bandwidth = bw)
  ..- attr(*, "class")= chr [1:2] "glkerns" "KernS"
 $ nu=1:List of 24
  ..$ x         : num [1:75] 0.00667 0.02 0.03333 0.04667 0.06 ...
  ..$ y         : num [1:75] 1.97 1.9 1.64 1.43 2.4 ...
  ..$ x.out     : num [1:300] 0.00667 0.01103 0.0154 0.01976 0.02 ...
  ..$ est       : num [1:300] -5.25 -4.5 -3.84 -3.28 -3.25 ...
  ..$ n         : int 75
  ..$ n.out     : int 300
  ..$ deriv     : int 1
  ..$ korder    : int 5
  ..$ hetero    : logi FALSE
  ..$ is.rand   : logi FALSE
  ..$ inputb    : logi TRUE
  ..$ iter      : int NA
  ..$ xl        : num 1
  ..$ xu        : num 0
  ..$ s         : num [1:76] 0 0.0133 0.0267 0.04 0.0533 ...
  ..$ sig       : num 0
  ..$ bandwidth : num 0.12
  ..$ ind.x     : int [1:75] 1 5 9 13 17 21 25 29 33 37 ...
  ..$ seqXmethod: chr "aim"
  ..$ m1        : int 400
  ..$ isOrd     : logi TRUE
  ..$ ord       : NULL
  ..$ x.inOut   : logi TRUE
  ..$ call      : language glkerns(x = x.dat, y = y.dat, deriv = nu, korder = k0, is.rand = is.rand,      bandwidth = bw)
  ..- attr(*, "class")= chr [1:2] "glkerns" "KernS"
 $ nu=2:List of 24
  ..$ x         : num [1:75] 0.00667 0.02 0.03333 0.04667 0.06 ...
  ..$ y         : num [1:75] 1.97 1.9 1.64 1.43 2.4 ...
  ..$ x.out     : num [1:300] 0.00667 0.01103 0.0154 0.01976 0.02 ...
  ..$ est       : num [1:300] -39.9 -39.7 -39.5 -39.2 -39.2 ...
  ..$ n         : int 75
  ..$ n.out     : int 300
  ..$ deriv     : int 2
  ..$ korder    : int 4
  ..$ hetero    : logi FALSE
  ..$ is.rand   : logi FALSE
  ..$ inputb    : logi TRUE
  ..$ iter      : int NA
  ..$ xl        : num 1
  ..$ xu        : num 0
  ..$ s         : num [1:76] 0 0.0133 0.0267 0.04 0.0533 ...
  ..$ sig       : num 0
  ..$ bandwidth : num 0.12
  ..$ ind.x     : int [1:75] 1 5 9 13 17 21 25 29 33 37 ...
  ..$ seqXmethod: chr "aim"
  ..$ m1        : int 400
  ..$ isOrd     : logi TRUE
  ..$ ord       : NULL
  ..$ x.inOut   : logi TRUE
  ..$ call      : language glkerns(x = x.dat, y = y.dat, deriv = nu, korder = k0, is.rand = is.rand,      bandwidth = bw)
  ..- attr(*, "class")= chr [1:2] "glkerns" "KernS"
> 
> p.3glks(tt, xSim, kord = 6, useB = 0.2, derivs = 0:3) # k.ord = (6,5,6, 5)
deriv = 1: modifying korder from 6 to 5
deriv = 3: modifying korder from 6 to 5
> 
> ## "FIXME" visually compare with numerical derivatives (e.g. from splines).
> 
