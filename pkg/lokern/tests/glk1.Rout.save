
R version 3.2.5 (2016-04-14) -- "Very, Very Secure Dishes"
Copyright (C) 2016 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> require(lokern)
Loading required package: lokern
> data(xSim)
> n <- length(xSim)
> stopifnot(n == 75)
> tt <- ((1:n) - 1/2)/n # equidistant x
> 
> (gk <- glkerns(tt, xSim))
Call:
glkerns.default(x = tt, y = xSim)
List of 23
 $ x         : num [1:75] 0.006666667 0.02 0.033333333 0.046666667 0.06 ...
 $ y         : num [1:75] 1.9666 1.9 1.6449 1.4275 2.4 1.8487 1.3383 1.9514 1.5722 1.1978 ...
 $ x.out     : num [1:300] 0.006666667 0.011032448 0.01539823 0.019764012 0.02 ...
 $ est       : num [1:300] 1.867502 1.860786 1.85407 1.847354 1.846991 ...
 $ nobs      : int 75
 $ n.out     : int 300
 $ deriv     : int 0
 $ korder    : int 2
 $ hetero    : logi FALSE
 $ is.rand   : logi TRUE
 $ inputb    : logi FALSE
 $ iter      : int 15
 $ xl        : num 0.067
 $ xu        : num 0.933
 $ s         : num [1:76] 0.004117607 0.013333333 0.026666667 0.04 0.053333333 ...
 $ sig       : num 0.1451065
 $ bandwidth : num 0.04845241
 $ ind.x     : int [1:75] 1 5 9 13 17 21 25 29 33 37 ...
 $ seqXmethod: chr "aim"
 $ m1        : int 400
 $ isOrd     : logi TRUE
 $ ord       : NULL
 $ x.inOut   : logi TRUE
> summary(gk$est)
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
-3.0680 -1.6680  0.7053  0.4094  1.7820  4.2130 
> gk$bandwidth
[1] 0.04845241
> glkerns(tt,xSim, deriv = 1)$bandwidth
[1] 0.08137163
> glkerns(tt,xSim, deriv = 2)$bandwidth
[1] 0.1190404
> 
> if(!grDevices::dev.interactive(orNone=TRUE)) pdf("glk-derivs-etc.pdf")
> 
> demo("glk-derivs", ask = FALSE)


	demo(glk-derivs)
	---- ~~~~~~~~~~

> ## Q: Can we have *same* kernel, *same* bandwidth  with different  'deriv'
> ##    similarly to smooth.spline() ?
> ##
> ## Answer: not really,  mainly because don't have enough choices
> ##     (nu, k_{ord}), i.e., because currently,  nu - k  must be even ...
> 
> ## "dput(.) of simple integer vector to character :
> myF <- function(d, A="(", O=")", B = length(d) > 1)
+     paste(if(B) A, paste(d, collapse=", "), if(B) O, sep="")

> library(lokern)

> p.3glks <- function(x.dat, y.dat, korder, derivs = 0:2,
+                     is.rand=FALSE, useBandwidth, bw.factor = 1.8,
+                     col = 2, lwd = 1.5)
+ {
+     ## Purpose: Plot  glkerns(*,  deriv = {0, 1, 2})
+     ## ----------------------------------------------------------------------
+     ## Arguments: (x.dat, y.dat): the numeric data vectors
+     ##            korder : the kernel order -- automatically is diminuished by one
+     ##                     if needed to keep  'korder - deriv' an even number
+     ##            derivs : integer vectors of derivatives to compute
+     ##            useBandwidth: possibly a user specified bandwidth
+     ## ----------------------------------------------------------------------
+     ## Author: Martin Maechler, Date:  2 Jul 2009, 09:24
+ 
+     if(!missing(useBandwidth) && is.numeric(useBandwidth) && useBandwidth > 0)
+         bw <- useBandwidth
+     else {
+         ## Determine the fixed bandwidth :
+         bw0 <- glkerns(x.dat, y.dat, korder=korder, is.rand=is.rand)$bandwidth
+         bw <- bw0 * bw.factor     # more smoothing for the derivatives
+     }
+ 
+     stopifnot(derivs == (d <- as.integer(derivs)), length(derivs) >= 1)
+     derivs <- d
+     stopifnot(0 <= derivs, derivs <= 4)
+     glist <- as.list(derivs)
+     ## Estimates for   g, g' , g'' ... {well, depending on derivs} :
+     for(i.d in seq_along(derivs)) {
+         nu <- derivs[i.d]
+         k0 <- korder
+         if((korder - nu) %% 2 != 0) { ## 'korder - nu' must be even {theory; Fortran code}
+             k0 <- korder - 1
+             message(gettextf("deriv = %d: modifying korder from %d to %d",
+                              nu, korder, k0))
+         }
+         glist[[i.d]] <-
+             glkerns(x.dat, y.dat, korder=k0, is.rand=is.rand, bandw = bw, deriv = nu)
+     }
+ 
+     names(glist) <- paste("nu=", derivs, sep="")
+ 
+     ## ---------  Plots ---------------
+ 
+     op <- par(mfrow= c(length(derivs), 1), mgp = c(1.25, 0.6, 0),
+               mar = c(3,3,2.5,1) + .1, oma = c(0,0, 2, 0))
+     on.exit(par(op))
+ 
+     for(i.d in seq_along(derivs)) {
+         nu <- derivs[i.d]
+         tit <-
+             switch(nu + 1,
+                    expression(widehat(g)(.)), # 0
+                    expression(widehat(g * minute)(.)), # 1: g'
+                    expression(widehat(g * second)(.)), # 2: g''
+                    expression(widehat(g * minute*second)(.)),# 3: g'''
+                    expression(widehat(g ^ {(4)})),
+                    expression(widehat(g ^ {(5)})),
+                    expression(widehat(g ^ {(6)})))
+ 
+         with(glist[[i.d]], {
+             plot(est ~ x.out, type = "l", main = tit, col=col, lwd=lwd)
+             if(nu == 0) ## data
+                 points(y ~ x, cex = 0.5)
+             else ## y = 0 line (to see zeros):
+                 abline(h = 0, col = "gray", lty=3)
+ 
+             mtext(substitute(list(bw == B,k[ord] == K),
+                              list(B = formatC(bandwidth), K = korder)),
+                   adj = 1, line = .25) })
+     }
+     mtext(sprintf("glkerns(*, deriv = %s, bandwidth = <fixed>, korder = %d)",
+                   myF(derivs, "{","}"), korder),
+           line = 0.5, outer = TRUE, cex = par("cex.main"), font = par("font.main"))
+ 
+     invisible(glist)
+ }

> data(xSim)

> n <- length(xSim)

> tt <- ((1:n) - 1/2)/n # equidistant x

> p.3glks(tt, xSim, kord = 4)
deriv = 1: modifying korder from 4 to 3

> ## Chose bandwidth yourself; see all available derivatives:
> ## Store results
> r <- p.3glks(tt, xSim, kord = 6,
+              derivs = 0:4, useBand = 0.15)
deriv = 1: modifying korder from 6 to 5
deriv = 3: modifying korder from 6 to 5

> ## and inspect them
> if(interactive())  print(r)
> ##   ------------
> stopifnot(lengths(r.est <- lapply(r, `[[`, "est")) == 300)
> rq <- sapply(r.est, quantile)
> stopifnot(
+     all.equal(
+         rq,
+         array(c(-3.05424, -1.741756, 0.6749366, 1.758692, 4.387521,
+                 -39.49606, -7.86697, -5.754756, -2.398544, 34.82773,
+                 -770.4308, -57.48376, 2.249302, 197.8807, 449.9687,
+                 -9002.222, -1537.481, 267.3216, 1870.717, 8486.839,
+                 -198315.3, -24259.81, 18925.91, 87331.48, 216498.5),
+               dim = c(5,5), dimnames = list(names(quantile(1)), names(r.est))),
+         tol = 7e-7) # 64b : 9.9e-8
+ )
> 
> p.3glks(tt, xSim, kord = 3)
deriv = 0: modifying korder from 3 to 2
deriv = 2: modifying korder from 3 to 2
Warning messages:
1: In .glkerns(x = x, y = y, x.out = x.out, nobs = n, n.out = n.out,  :
  'korder' reset from 3 to 2, internally
2: In .glkerns(x = x, y = y, x.out = x.out, nobs = n, n.out = n.out,  :
  'korder' reset from 2 to 4, internally
> 
> p.3glks(tt, xSim, kord = 4, useB = 0.15)
deriv = 1: modifying korder from 4 to 3
> 
> print(
+     p.3glks(tt, xSim, kord = 5, useB = 0.12) # k.ord = (4,5,4) => less sensical?
+     )
deriv = 0: modifying korder from 5 to 4
deriv = 2: modifying korder from 5 to 4
$`nu=0`
Call:
glkerns.default(x = x.dat, y = y.dat, deriv = nu, korder = k0, 
    is.rand = is.rand, bandwidth = bw)
List of 23
 $ x         : num [1:75] 0.006666667 0.02 0.033333333 0.046666667 0.06 ...
 $ y         : num [1:75] 1.9666 1.9 1.6449 1.4275 2.4 1.8487 1.3383 1.9514 1.5722 1.1978 ...
 $ x.out     : num [1:300] 0.006666667 0.011032448 0.01539823 0.019764012 0.02 ...
 $ est       : num [1:300] 1.885277 1.881011 1.875988 1.870213 1.869879 ...
 $ nobs      : int 75
 $ n.out     : int 300
 $ deriv     : int 0
 $ korder    : int 4
 $ hetero    : logi FALSE
 $ is.rand   : logi FALSE
 $ inputb    : logi TRUE
 $ iter      : int NA
 $ xl        : num 1
 $ xu        : num 0
 $ s         : num [1:76] 0 0.01333333 0.02666667 0.04 0.05333333 ...
 $ sig       : num 0
 $ bandwidth : num 0.12
 $ ind.x     : int [1:75] 1 5 9 13 17 21 25 29 33 37 ...
 $ seqXmethod: chr "aim"
 $ m1        : int 400
 $ isOrd     : logi TRUE
 $ ord       : NULL
 $ x.inOut   : logi TRUE

$`nu=1`
Call:
glkerns.default(x = x.dat, y = y.dat, deriv = nu, korder = k0, 
    is.rand = is.rand, bandwidth = bw)
List of 23
 $ x         : num [1:75] 0.006666667 0.02 0.033333333 0.046666667 0.06 ...
 $ y         : num [1:75] 1.9666 1.9 1.6449 1.4275 2.4 1.8487 1.3383 1.9514 1.5722 1.1978 ...
 $ x.out     : num [1:300] 0.006666667 0.011032448 0.01539823 0.019764012 0.02 ...
 $ est       : num [1:300] -5.251133 -4.498137 -3.84347 -3.282598 -3.254864 ...
 $ nobs      : int 75
 $ n.out     : int 300
 $ deriv     : int 1
 $ korder    : int 5
 $ hetero    : logi FALSE
 $ is.rand   : logi FALSE
 $ inputb    : logi TRUE
 $ iter      : int NA
 $ xl        : num 1
 $ xu        : num 0
 $ s         : num [1:76] 0 0.01333333 0.02666667 0.04 0.05333333 ...
 $ sig       : num 0
 $ bandwidth : num 0.12
 $ ind.x     : int [1:75] 1 5 9 13 17 21 25 29 33 37 ...
 $ seqXmethod: chr "aim"
 $ m1        : int 400
 $ isOrd     : logi TRUE
 $ ord       : NULL
 $ x.inOut   : logi TRUE

$`nu=2`
Call:
glkerns.default(x = x.dat, y = y.dat, deriv = nu, korder = k0, 
    is.rand = is.rand, bandwidth = bw)
List of 23
 $ x         : num [1:75] 0.006666667 0.02 0.033333333 0.046666667 0.06 ...
 $ y         : num [1:75] 1.9666 1.9 1.6449 1.4275 2.4 1.8487 1.3383 1.9514 1.5722 1.1978 ...
 $ x.out     : num [1:300] 0.006666667 0.011032448 0.01539823 0.019764012 0.02 ...
 $ est       : num [1:300] -39.91204 -39.68558 -39.45924 -39.23299 -39.22077 ...
 $ nobs      : int 75
 $ n.out     : int 300
 $ deriv     : int 2
 $ korder    : int 4
 $ hetero    : logi FALSE
 $ is.rand   : logi FALSE
 $ inputb    : logi TRUE
 $ iter      : int NA
 $ xl        : num 1
 $ xu        : num 0
 $ s         : num [1:76] 0 0.01333333 0.02666667 0.04 0.05333333 ...
 $ sig       : num 0
 $ bandwidth : num 0.12
 $ ind.x     : int [1:75] 1 5 9 13 17 21 25 29 33 37 ...
 $ seqXmethod: chr "aim"
 $ m1        : int 400
 $ isOrd     : logi TRUE
 $ ord       : NULL
 $ x.inOut   : logi TRUE

> 
> p.3glks(tt, xSim, kord = 6, useB = 0.2, derivs = 0:3) # k.ord = (6,5,6, 5)
deriv = 1: modifying korder from 6 to 5
deriv = 3: modifying korder from 6 to 5
> 
> ## "FIXME" visually compare with numerical derivatives (e.g. from splines).
> 
> proc.time()
   user  system elapsed 
  0.306   0.047   0.466 
